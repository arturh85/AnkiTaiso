{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Ky\u014dkai Tansa Docs Project Documentation organised by The Documentation System . There is a secret that needs to be understood in order to write good software documentation: there isn\u2019t one thing called documentation, there are four. They are: tutorials , how-to guides , technical reference and explanation . They represent four different purposes or functions, and require four different approaches to their creation. Understanding the implications of this will help improve most documentation - often immensely. Tutorials How-to guides Reference Explanation oriented to learning a goal information understanding must allow the newcomer to get started show how to solve a specific problem describe the machinery explain its form a lesson a series of steps dry description discursive explanation analogy teaching a small child how to cook a recipe in a cookery book a reference encyclopedia article an article on culinary social history","title":"Home"},{"location":"#kyokai-tansa-docs","text":"Project Documentation organised by The Documentation System . There is a secret that needs to be understood in order to write good software documentation: there isn\u2019t one thing called documentation, there are four. They are: tutorials , how-to guides , technical reference and explanation . They represent four different purposes or functions, and require four different approaches to their creation. Understanding the implications of this will help improve most documentation - often immensely. Tutorials How-to guides Reference Explanation oriented to learning a goal information understanding must allow the newcomer to get started show how to solve a specific problem describe the machinery explain its form a lesson a series of steps dry description discursive explanation analogy teaching a small child how to cook a recipe in a cookery book a reference encyclopedia article an article on culinary social history","title":"Ky\u014dkai Tansa Docs"},{"location":"explanation/how-godot-works/","text":"How Godot works (TDB)","title":"How Godot works"},{"location":"explanation/how-godot-works/#how-godot-works","text":"(TDB)","title":"How Godot works"},{"location":"howto/tests/","text":"\ud83d\udea5 Tests Tests run directly inside the GitHub runner machine (using [chickensoft-games/setup-godot]) on every push to the repository. If the tests fail to pass, the workflow will also fail to pass. You can configure which simulated graphics environments ( vulkan and/or opengl3 ) you want to run tests on in .github/workflows/visual_tests.yaml . Currently, tests can only be run from the ubuntu runners. If you know how to make the workflow install mesa and a virtual window manager on macOS and Windows, we'd love to hear from you! Tests are executed by running the Godot test project in kyoukai-tansa from the command line and passing in the relevant arguments to Godot so that [GoDotTest] can discover and run tests. \ud83d\udc77 Testing An example test is included in test/src/GameTest.cs that demonstrates how to write a test for your package using [GoDotTest] and [godot-test-driver]. [GoDotTest] is an easy-to-use testing framework for Godot and C# that allows you to run tests from the command line, collect code coverage, and debug tests in VSCode. Tests run directly inside the game. The .csproj file is already pre-configured to prevent test scripts and test-only package dependencies from being included in release builds of your game! On CI/CD, software graphics drivers from [mesa] emulate a virtual graphics device for Godot to render to, allowing you to run visual tests in a headless environment. \ud83d\udea6 Test Coverage Code coverage requires a few dotnet global tools to be installed first. You should install these tools from the root of the project directory. The nuget.config file in the root of the project allows the correct version of coverlet to be installed from the coverlet nightly distributions. Overriding the coverlet version will be required [until coverlet releases a stable version with the fixes that allow it to work with Godot 4][coverlet-issues]. dotnet tool install --global coverlet.console dotnet tool update --global coverlet.console dotnet tool install --global dotnet-reportgenerator-globaltool dotnet tool update --global dotnet-reportgenerator-globaltool Running dotnet tool update for the global tool is often necessary on Apple Silicon computers to ensure the tools are installed correctly. You can collect code coverage and generate coverage badges by running the bash script coverage.sh (on Windows, you can use the Git Bash shell that comes with git). # Must give coverage script permission to run the first time it is used. chmod +x ./coverage.sh # Run code coverage: ./coverage.sh You can also run test coverage through VSCode by opening the command palette and selecting Tasks: Run Task and then choosing coverage . If you are having trouble with coverlet finding your .NET runtime on Windows, you can use the PowerShell Script coverage.ps1 instead. .\\coverage.ps1","title":"Tests"},{"location":"howto/tests/#tests","text":"Tests run directly inside the GitHub runner machine (using [chickensoft-games/setup-godot]) on every push to the repository. If the tests fail to pass, the workflow will also fail to pass. You can configure which simulated graphics environments ( vulkan and/or opengl3 ) you want to run tests on in .github/workflows/visual_tests.yaml . Currently, tests can only be run from the ubuntu runners. If you know how to make the workflow install mesa and a virtual window manager on macOS and Windows, we'd love to hear from you! Tests are executed by running the Godot test project in kyoukai-tansa from the command line and passing in the relevant arguments to Godot so that [GoDotTest] can discover and run tests.","title":"\ud83d\udea5 Tests"},{"location":"howto/tests/#testing","text":"An example test is included in test/src/GameTest.cs that demonstrates how to write a test for your package using [GoDotTest] and [godot-test-driver]. [GoDotTest] is an easy-to-use testing framework for Godot and C# that allows you to run tests from the command line, collect code coverage, and debug tests in VSCode. Tests run directly inside the game. The .csproj file is already pre-configured to prevent test scripts and test-only package dependencies from being included in release builds of your game! On CI/CD, software graphics drivers from [mesa] emulate a virtual graphics device for Godot to render to, allowing you to run visual tests in a headless environment.","title":"\ud83d\udc77 Testing"},{"location":"howto/tests/#test-coverage","text":"Code coverage requires a few dotnet global tools to be installed first. You should install these tools from the root of the project directory. The nuget.config file in the root of the project allows the correct version of coverlet to be installed from the coverlet nightly distributions. Overriding the coverlet version will be required [until coverlet releases a stable version with the fixes that allow it to work with Godot 4][coverlet-issues]. dotnet tool install --global coverlet.console dotnet tool update --global coverlet.console dotnet tool install --global dotnet-reportgenerator-globaltool dotnet tool update --global dotnet-reportgenerator-globaltool Running dotnet tool update for the global tool is often necessary on Apple Silicon computers to ensure the tools are installed correctly. You can collect code coverage and generate coverage badges by running the bash script coverage.sh (on Windows, you can use the Git Bash shell that comes with git). # Must give coverage script permission to run the first time it is used. chmod +x ./coverage.sh # Run code coverage: ./coverage.sh You can also run test coverage through VSCode by opening the command palette and selecting Tasks: Run Task and then choosing coverage . If you are having trouble with coverlet finding your .NET runtime on Windows, you can use the PowerShell Script coverage.ps1 instead. .\\coverage.ps1","title":"\ud83d\udea6 Test Coverage"},{"location":"howto/update-godot-version/","text":"\ud83d\uddc2 Godot Version Change The included workflow in .github/workflows/version_change.yaml can be manually dispatched to open a pull request that replaces the version number in kyoukai-tansa.csproj with the version you specify in the workflow's inputs.","title":"Update godot version"},{"location":"howto/update-godot-version/#godot-version-change","text":"The included workflow in .github/workflows/version_change.yaml can be manually dispatched to open a pull request that replaces the version number in kyoukai-tansa.csproj with the version you specify in the workflow's inputs.","title":"\ud83d\uddc2 Godot Version Change"},{"location":"reference/api/","text":"Api (TDB)","title":"Api"},{"location":"reference/api/#api","text":"(TDB)","title":"Api"},{"location":"reference/godot-editor-shortcuts/","text":"Godot Editor Shortcuts The following are additional Godot Editor Shortcuts via addons: Expand Region ALT+W : expand region (macos CONTROL+W ) ALT+SHIFT+W : shrink region (macos CONTROL+SHIFT+W ) Find Everywhere SHIFT-SHIFT : Quick Open ALT+SHIFT+F : Find in Files (macos CONTROL+SHIFT+F ) Previous Tab Ctrl+Tab : Switch to the previously active tab (last tab) by pressing (macos Option+Tab )","title":"Godot Editor Shortcuts"},{"location":"reference/godot-editor-shortcuts/#godot-editor-shortcuts","text":"The following are additional Godot Editor Shortcuts via addons:","title":"Godot Editor Shortcuts"},{"location":"reference/godot-editor-shortcuts/#expand-region","text":"ALT+W : expand region (macos CONTROL+W ) ALT+SHIFT+W : shrink region (macos CONTROL+SHIFT+W )","title":"Expand Region"},{"location":"reference/godot-editor-shortcuts/#find-everywhere","text":"SHIFT-SHIFT : Quick Open ALT+SHIFT+F : Find in Files (macos CONTROL+SHIFT+F )","title":"Find Everywhere"},{"location":"reference/godot-editor-shortcuts/#previous-tab","text":"Ctrl+Tab : Switch to the previously active tab (last tab) by pressing (macos Option+Tab )","title":"Previous Tab"},{"location":"reference/spellcheck/","text":"\ud83e\uddd1\u200d\ud83c\udfeb Spellcheck A spell check runs on every push to the repository. The spellcheck workflow settings can be configured in .github/workflows/spellcheck.yaml . The [Code Spell Checker][cspell] plugin for VSCode is recommended to help you catch typos before you commit them. If you need add a word to the dictionary or ignore a certain path, you can edit the project's cspell.json file. You can also words to the local cspell.json file from VSCode by hovering over a misspelled word and selecting Quick Fix... and then Add \"{word}\" to config: cspell.json .","title":"Spellcheck"},{"location":"reference/spellcheck/#spellcheck","text":"A spell check runs on every push to the repository. The spellcheck workflow settings can be configured in .github/workflows/spellcheck.yaml . The [Code Spell Checker][cspell] plugin for VSCode is recommended to help you catch typos before you commit them. If you need add a word to the dictionary or ignore a certain path, you can edit the project's cspell.json file. You can also words to the local cspell.json file from VSCode by hovering over a misspelled word and selecting Quick Fix... and then Add \"{word}\" to config: cspell.json .","title":"\ud83e\uddd1\u200d\ud83c\udfeb Spellcheck"},{"location":"reference/state-flow/","text":"State Flow App Logic cd1563136f7b17f5ee6a35fd50ce04a6836c8bd01ef2f9fa2901d7f7cb7da48e0860d7ad99f075b90b6e738625a6893fb6fc4317434299ad1d58fdb04f083f0c 9a8c04e5631636245ba1ba7e9868d316b96a946af4d30f1581fdc5f7301e5eb5a797aa0acbcf833425212000d12ae9a842716e99e146047063904d7144ab9cc9 Game Logic ef574d706c17da2ad74d83360bd31e7f03ce46682c95ad73cfa01e403dd127098f40d327a7db0dce67b019810aca7c234cf0c3851b63af457d027ab577250dad c106fa57e097e0855c138362a195006278fc169788afeb7df98a28863128a91abef906ff0f534bfaba54c663b5f54898c093fcf703e7d1b1b61e28b9e291861e","title":"State Flow"},{"location":"reference/state-flow/#state-flow","text":"","title":"State Flow"},{"location":"reference/state-flow/#app-logic","text":"cd1563136f7b17f5ee6a35fd50ce04a6836c8bd01ef2f9fa2901d7f7cb7da48e0860d7ad99f075b90b6e738625a6893fb6fc4317434299ad1d58fdb04f083f0c 9a8c04e5631636245ba1ba7e9868d316b96a946af4d30f1581fdc5f7301e5eb5a797aa0acbcf833425212000d12ae9a842716e99e146047063904d7144ab9cc9","title":"App Logic"},{"location":"reference/state-flow/#game-logic","text":"ef574d706c17da2ad74d83360bd31e7f03ce46682c95ad73cfa01e403dd127098f40d327a7db0dce67b019810aca7c234cf0c3851b63af457d027ab577250dad c106fa57e097e0855c138362a195006278fc169788afeb7df98a28863128a91abef906ff0f534bfaba54c663b5f54898c093fcf703e7d1b1b61e28b9e291861e","title":"Game Logic"},{"location":"tutorial/getting-started/","text":"Getting Started \ud83e\udd5a Getting Started First install GodotEnv which manages our addons: dotnet tool install --global Chickensoft.GodotEnv Then we install all addons with this command: godotenv addons install \ud83c\udfdd Environment Setup For the provided debug configurations and test coverage to work correctly, you must setup your development environment correctly. The [Chickensoft Setup Docs][setup-docs] describe how to setup your Godot and C# development environment, using Chickensoft's best practice recommendations. VSCode Settings This template includes some Visual Studio Code settings in .vscode/settings.json . The settings facilitate terminal environments on Windows (Git Bash, PowerShell, Command Prompt) and macOS (zsh), as well as fixing some syntax colorization issues that Omnisharp suffers from. You'll also find settings that enable editor config support in Omnisharp and the .NET Roslyn analyzers for a more enjoyable coding experience. Please double-check that the provided VSCode settings don't conflict with your existing settings. .NET Versioning The included global.json specifies the version of the .NET SDK and Godot.NET.Sdk that the game should use. Using a global.json file allows [Renovatebot] to provide your repository with automatic dependency update pull requests whenever a new version of [GodotSharp] is released. \ud83c\udfc1 Application Entry Point The Main.tscn and Main.cs scene and script file are the entry point of your game. In general, you probably won't need to modify these unless you're doing something highly custom. If the game is running a release build, the Main.cs file will just immediately change the scene to src/Game.tscn . If the game is running in debug mode and GoDotTest has received the correct command line arguments to begin testing, the game will switch to the testing scene and hand off control to GoDotTest to run the game's tests. In general, prefer editing src/Game.tscn over src/Main.tscn . The provided debug configurations in .vscode/launch.json allow you to easily debug tests (or just the currently open test, provided its filename matches its class name). \u23ef Running the Project Several launch profiles are included for Visual Studio Code: \ud83d\udd79 Debug Game Runs the game in debug mode, allowing you to set breakpoints and inspect variables. \ud83c\udfad Debug Current Scene Debugs the game and loads the scene with the same name and in the same path as the C# file that's actively selected in VSCode: e.g., a scene named MyScene.tscn must reside in the same directory as MyScene.cs , and you must have selected MyScene.cs as the active tab in VSCode before running the launch profile. If GoDotTest is able to find a .tscn file with the same name in the same location, it will run the game in debug mode and load the scene. Naturally, Chickensoft recommends naming scenes after the C# script they use and keeping them in the same directory so that you can take advantage of this launch profile. \u26a0\ufe0f It's very easy to rename a script class but forget to rename the scene file, or vice-versa. When that happens, this launch profile will pass in the expected name of the scene file based on the script's name, but Godot will fail to find a scene with that name since the script name and scene name are not the same. \ud83e\uddea Debug Tests Runs the game in debug mode, specifying the command line flags needed by GoDotTest to run the tests. Debugging works the same as usual, allowing you to set breakpoints within the game's C# test files. \ud83d\udd2c Debug Current Test Debugs the game and loads the test class with the same name as the C# file that's actively selected in VSCode: e.g., a test file named MyTest.cs must contain a test class named MyTest , and you must have selected MyTest.cs as the active tab in VSCode before running the launch profile. \u26a0\ufe0f It's very easy to rename a test class but forget to rename the test file, or vice-versa. When that happens, this launch profile will pass in the name of the file but GoDotTest will fail to find a class with that name since the filename and class name are not the same. Note that each launch profile will trigger a build (see ./.vscode/tasks.json ) before debugging the game. \u26a0\ufe0f Important: You must setup a GODOT environment variable for the launch configurations above. If you haven't done so already, please see the [Chickensoft Setup Docs][setup-docs].","title":"Getting Started"},{"location":"tutorial/getting-started/#getting-started","text":"","title":"Getting Started"},{"location":"tutorial/getting-started/#getting-started_1","text":"First install GodotEnv which manages our addons: dotnet tool install --global Chickensoft.GodotEnv Then we install all addons with this command: godotenv addons install","title":"\ud83e\udd5a Getting Started"},{"location":"tutorial/getting-started/#environment-setup","text":"For the provided debug configurations and test coverage to work correctly, you must setup your development environment correctly. The [Chickensoft Setup Docs][setup-docs] describe how to setup your Godot and C# development environment, using Chickensoft's best practice recommendations.","title":"\ud83c\udfdd Environment Setup"},{"location":"tutorial/getting-started/#vscode-settings","text":"This template includes some Visual Studio Code settings in .vscode/settings.json . The settings facilitate terminal environments on Windows (Git Bash, PowerShell, Command Prompt) and macOS (zsh), as well as fixing some syntax colorization issues that Omnisharp suffers from. You'll also find settings that enable editor config support in Omnisharp and the .NET Roslyn analyzers for a more enjoyable coding experience. Please double-check that the provided VSCode settings don't conflict with your existing settings.","title":"VSCode Settings"},{"location":"tutorial/getting-started/#net-versioning","text":"The included global.json specifies the version of the .NET SDK and Godot.NET.Sdk that the game should use. Using a global.json file allows [Renovatebot] to provide your repository with automatic dependency update pull requests whenever a new version of [GodotSharp] is released.","title":".NET Versioning"},{"location":"tutorial/getting-started/#application-entry-point","text":"The Main.tscn and Main.cs scene and script file are the entry point of your game. In general, you probably won't need to modify these unless you're doing something highly custom. If the game is running a release build, the Main.cs file will just immediately change the scene to src/Game.tscn . If the game is running in debug mode and GoDotTest has received the correct command line arguments to begin testing, the game will switch to the testing scene and hand off control to GoDotTest to run the game's tests. In general, prefer editing src/Game.tscn over src/Main.tscn . The provided debug configurations in .vscode/launch.json allow you to easily debug tests (or just the currently open test, provided its filename matches its class name).","title":"\ud83c\udfc1 Application Entry Point"},{"location":"tutorial/getting-started/#running-the-project","text":"Several launch profiles are included for Visual Studio Code: \ud83d\udd79 Debug Game Runs the game in debug mode, allowing you to set breakpoints and inspect variables. \ud83c\udfad Debug Current Scene Debugs the game and loads the scene with the same name and in the same path as the C# file that's actively selected in VSCode: e.g., a scene named MyScene.tscn must reside in the same directory as MyScene.cs , and you must have selected MyScene.cs as the active tab in VSCode before running the launch profile. If GoDotTest is able to find a .tscn file with the same name in the same location, it will run the game in debug mode and load the scene. Naturally, Chickensoft recommends naming scenes after the C# script they use and keeping them in the same directory so that you can take advantage of this launch profile. \u26a0\ufe0f It's very easy to rename a script class but forget to rename the scene file, or vice-versa. When that happens, this launch profile will pass in the expected name of the scene file based on the script's name, but Godot will fail to find a scene with that name since the script name and scene name are not the same. \ud83e\uddea Debug Tests Runs the game in debug mode, specifying the command line flags needed by GoDotTest to run the tests. Debugging works the same as usual, allowing you to set breakpoints within the game's C# test files. \ud83d\udd2c Debug Current Test Debugs the game and loads the test class with the same name as the C# file that's actively selected in VSCode: e.g., a test file named MyTest.cs must contain a test class named MyTest , and you must have selected MyTest.cs as the active tab in VSCode before running the launch profile. \u26a0\ufe0f It's very easy to rename a test class but forget to rename the test file, or vice-versa. When that happens, this launch profile will pass in the name of the file but GoDotTest will fail to find a class with that name since the filename and class name are not the same. Note that each launch profile will trigger a build (see ./.vscode/tasks.json ) before debugging the game. \u26a0\ufe0f Important: You must setup a GODOT environment variable for the launch configurations above. If you haven't done so already, please see the [Chickensoft Setup Docs][setup-docs].","title":"\u23ef Running the Project"}]}