{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Ky\u014dkai Tansa Docs Project Documentation organised by The Documentation System . There is a secret that needs to be understood in order to write good software documentation: there isn\u2019t one thing called documentation, there are four. They are: tutorials , how-to guides , technical reference and explanation . They represent four different purposes or functions, and require four different approaches to their creation. Understanding the implications of this will help improve most documentation - often immensely. Tutorials How-to guides Reference Explanation oriented to learning a goal information understanding must allow the newcomer to get started show how to solve a specific problem describe the machinery explain its form a lesson a series of steps dry description discursive explanation analogy teaching a small child how to cook a recipe in a cookery book a reference encyclopedia article an article on culinary social history","title":"Home"},{"location":"#kyokai-tansa-docs","text":"Project Documentation organised by The Documentation System . There is a secret that needs to be understood in order to write good software documentation: there isn\u2019t one thing called documentation, there are four. They are: tutorials , how-to guides , technical reference and explanation . They represent four different purposes or functions, and require four different approaches to their creation. Understanding the implications of this will help improve most documentation - often immensely. Tutorials How-to guides Reference Explanation oriented to learning a goal information understanding must allow the newcomer to get started show how to solve a specific problem describe the machinery explain its form a lesson a series of steps dry description discursive explanation analogy teaching a small child how to cook a recipe in a cookery book a reference encyclopedia article an article on culinary social history","title":"Ky\u014dkai Tansa Docs"},{"location":"explanation/how-godot-works/","text":"How Godot works (TDB)","title":"How Godot works"},{"location":"explanation/how-godot-works/#how-godot-works","text":"(TDB)","title":"How Godot works"},{"location":"howto/tests/","text":"\ud83d\udea5 Tests Tests run directly inside the GitHub runner machine (using [chickensoft-games/setup-godot]) on every push to the repository. If the tests fail to pass, the workflow will also fail to pass. You can configure which simulated graphics environments ( vulkan and/or opengl3 ) you want to run tests on in .github/workflows/visual_tests.yaml . Currently, tests can only be run from the ubuntu runners. If you know how to make the workflow install mesa and a virtual window manager on macOS and Windows, we'd love to hear from you! Tests are executed by running the Godot test project in anki-taiso from the command line and passing in the relevant arguments to Godot so that [GoDotTest] can discover and run tests. \ud83d\udc77 Testing An example test is included in test/src/GameTest.cs that demonstrates how to write a test for your package using [GoDotTest] and [godot-test-driver]. [GoDotTest] is an easy-to-use testing framework for Godot and C# that allows you to run tests from the command line, collect code coverage, and debug tests in VSCode. Tests run directly inside the game. The .csproj file is already pre-configured to prevent test scripts and test-only package dependencies from being included in release builds of your game! On CI/CD, software graphics drivers from [mesa] emulate a virtual graphics device for Godot to render to, allowing you to run visual tests in a headless environment. \ud83d\udea6 Test Coverage Code coverage requires a few dotnet global tools to be installed first. You should install these tools from the root of the project directory. The nuget.config file in the root of the project allows the correct version of coverlet to be installed from the coverlet nightly distributions. Overriding the coverlet version will be required [until coverlet releases a stable version with the fixes that allow it to work with Godot 4][coverlet-issues]. dotnet tool install --global coverlet.console dotnet tool update --global coverlet.console dotnet tool install --global dotnet-reportgenerator-globaltool dotnet tool update --global dotnet-reportgenerator-globaltool Running dotnet tool update for the global tool is often necessary on Apple Silicon computers to ensure the tools are installed correctly. You can collect code coverage and generate coverage badges by running the bash script coverage.sh (on Windows, you can use the Git Bash shell that comes with git). # Must give coverage script permission to run the first time it is used. chmod +x ./coverage.sh # Run code coverage: ./coverage.sh You can also run test coverage through VSCode by opening the command palette and selecting Tasks: Run Task and then choosing coverage . If you are having trouble with coverlet finding your .NET runtime on Windows, you can use the PowerShell Script coverage.ps1 instead. .\\coverage.ps1","title":"Tests"},{"location":"howto/tests/#tests","text":"Tests run directly inside the GitHub runner machine (using [chickensoft-games/setup-godot]) on every push to the repository. If the tests fail to pass, the workflow will also fail to pass. You can configure which simulated graphics environments ( vulkan and/or opengl3 ) you want to run tests on in .github/workflows/visual_tests.yaml . Currently, tests can only be run from the ubuntu runners. If you know how to make the workflow install mesa and a virtual window manager on macOS and Windows, we'd love to hear from you! Tests are executed by running the Godot test project in anki-taiso from the command line and passing in the relevant arguments to Godot so that [GoDotTest] can discover and run tests.","title":"\ud83d\udea5 Tests"},{"location":"howto/tests/#testing","text":"An example test is included in test/src/GameTest.cs that demonstrates how to write a test for your package using [GoDotTest] and [godot-test-driver]. [GoDotTest] is an easy-to-use testing framework for Godot and C# that allows you to run tests from the command line, collect code coverage, and debug tests in VSCode. Tests run directly inside the game. The .csproj file is already pre-configured to prevent test scripts and test-only package dependencies from being included in release builds of your game! On CI/CD, software graphics drivers from [mesa] emulate a virtual graphics device for Godot to render to, allowing you to run visual tests in a headless environment.","title":"\ud83d\udc77 Testing"},{"location":"howto/tests/#test-coverage","text":"Code coverage requires a few dotnet global tools to be installed first. You should install these tools from the root of the project directory. The nuget.config file in the root of the project allows the correct version of coverlet to be installed from the coverlet nightly distributions. Overriding the coverlet version will be required [until coverlet releases a stable version with the fixes that allow it to work with Godot 4][coverlet-issues]. dotnet tool install --global coverlet.console dotnet tool update --global coverlet.console dotnet tool install --global dotnet-reportgenerator-globaltool dotnet tool update --global dotnet-reportgenerator-globaltool Running dotnet tool update for the global tool is often necessary on Apple Silicon computers to ensure the tools are installed correctly. You can collect code coverage and generate coverage badges by running the bash script coverage.sh (on Windows, you can use the Git Bash shell that comes with git). # Must give coverage script permission to run the first time it is used. chmod +x ./coverage.sh # Run code coverage: ./coverage.sh You can also run test coverage through VSCode by opening the command palette and selecting Tasks: Run Task and then choosing coverage . If you are having trouble with coverlet finding your .NET runtime on Windows, you can use the PowerShell Script coverage.ps1 instead. .\\coverage.ps1","title":"\ud83d\udea6 Test Coverage"},{"location":"howto/update-godot-version/","text":"\ud83d\uddc2 Godot Version Change The included workflow in .github/workflows/version_change.yaml can be manually dispatched to open a pull request that replaces the version number in anki-taiso.csproj with the version you specify in the workflow's inputs.","title":"Update godot version"},{"location":"howto/update-godot-version/#godot-version-change","text":"The included workflow in .github/workflows/version_change.yaml can be manually dispatched to open a pull request that replaces the version number in anki-taiso.csproj with the version you specify in the workflow's inputs.","title":"\ud83d\uddc2 Godot Version Change"},{"location":"reference/api/","text":"Api (TDB)","title":"Api"},{"location":"reference/api/#api","text":"(TDB)","title":"Api"},{"location":"reference/godot-editor-shortcuts/","text":"Godot Editor Shortcuts The following are additional Godot Editor Shortcuts via addons: Expand Region ALT+W : expand region (macos CONTROL+W ) ALT+SHIFT+W : shrink region (macos CONTROL+SHIFT+W ) Find Everywhere SHIFT-SHIFT : Quick Open ALT+SHIFT+F : Find in Files (macos CONTROL+SHIFT+F ) Previous Tab Ctrl+Tab : Switch to the previously active tab (last tab) by pressing (macos Option+Tab )","title":"Godot Editor Shortcuts"},{"location":"reference/godot-editor-shortcuts/#godot-editor-shortcuts","text":"The following are additional Godot Editor Shortcuts via addons:","title":"Godot Editor Shortcuts"},{"location":"reference/godot-editor-shortcuts/#expand-region","text":"ALT+W : expand region (macos CONTROL+W ) ALT+SHIFT+W : shrink region (macos CONTROL+SHIFT+W )","title":"Expand Region"},{"location":"reference/godot-editor-shortcuts/#find-everywhere","text":"SHIFT-SHIFT : Quick Open ALT+SHIFT+F : Find in Files (macos CONTROL+SHIFT+F )","title":"Find Everywhere"},{"location":"reference/godot-editor-shortcuts/#previous-tab","text":"Ctrl+Tab : Switch to the previously active tab (last tab) by pressing (macos Option+Tab )","title":"Previous Tab"},{"location":"reference/spellcheck/","text":"\ud83e\uddd1\u200d\ud83c\udfeb Spellcheck A spell check runs on every push to the repository. The spellcheck workflow settings can be configured in .github/workflows/spellcheck.yaml . The [Code Spell Checker][cspell] plugin for VSCode is recommended to help you catch typos before you commit them. If you need add a word to the dictionary or ignore a certain path, you can edit the project's cspell.json file. You can also words to the local cspell.json file from VSCode by hovering over a misspelled word and selecting Quick Fix... and then Add \"{word}\" to config: cspell.json .","title":"Spellcheck"},{"location":"reference/spellcheck/#spellcheck","text":"A spell check runs on every push to the repository. The spellcheck workflow settings can be configured in .github/workflows/spellcheck.yaml . The [Code Spell Checker][cspell] plugin for VSCode is recommended to help you catch typos before you commit them. If you need add a word to the dictionary or ignore a certain path, you can edit the project's cspell.json file. You can also words to the local cspell.json file from VSCode by hovering over a misspelled word and selecting Quick Fix... and then Add \"{word}\" to config: cspell.json .","title":"\ud83e\uddd1\u200d\ud83c\udfeb Spellcheck"},{"location":"reference/state-flow/","text":"State Flow App Logic a5dc9b1b5d426960c70a734a436dfece90ef21dcaa9849e348c183a3dc7b4f5c1ec05d40601fc3d7e940ec086641632ea7c6dc7dfde2c17a17e27b9f1db6d77b 116d2aa4babe3e25eb2955a4f6c2adc92694e7d5283cf5a2a99fcb7f7a18980c13f430c1dfca5cae17b0b5ed16ba044c25b9033814d29befba9d7cef83caac98 Coin Logic e34fa993fc43c357be28e34513cf202e985ed5c95a4908b6c58d7c368bc348d53551dd36f31fca7968bdd5b02ff82a72ff5cfb1b836cce4f4df6725328184e7b 1169083d9530223d3dae954e555671be78cc739521cc8892ac149b53dba22b0a5b78afd8c725a3d4bd4bd28c9954aa71aa500d1543e7fa357f65c6a9b11c9c77 Game Logic 941fe50d45c82a09d30629f93ce99318d102312ab5a295fea00b1ca73c6e7a27a1925ab6cd3017106b2f3884583bea58db39bfab37edca0fd378f3b0798372d3 b32bc886281c68ed96d6f9fe184ad7b6221f80975e559bae981c6e7bc832def85c3cfb14644287a505eedfdbf3096109d3a4b131f3dc921066e0ec7fa8926eb9 Game Typing Logic ed48db3fa3da6bc16498600ba483b6d46edb886f283599fcaee2a4f9fd379e113009e443b7f0c6fd63c9dee1834ff0138f2f8a4d7c4e6317f99497e6847fe3ca 140edc16054050e9232e9cf653f1e5a61d505bcb582297e13fe92e43169dd71f01b6c9d27206a6d390658c0ac3f91a92f167b91e563c7505dbff9241b9547070 In Game Audio Logic 8e06ee689a964ae3d10df7d14bf0c912d77f3c1c931e3c75b9f94348b878bfcbd2e7b324f1e6b669c89f13c2db5e2e502697d338a9ab6ac56bc07977f7a74aa0 d148dd4d1b7bb67b07e8d5e78889604bf6aa9e656062e3262d3bd57648d06ea1b3af207844e0d2763f5c90abbdf3bb9b2c4a9a66761cd41d95698f52b9dfb0c7 In Game U I Logic 1fa36a0f99d147abb1cf60d1eab07fe31356dc124bcbeb53126eda72863ebcd40541b95cba5921b3f301b9e0458db3117beb4bed6a2ab5bc295382ed5d550c39 5f380453eeab45bd081ebdd0ea879ba074199b96b1dee648a69dfa9b33f007bb5e699c7136eab7f6edb1812f81e54e61ee9b66fb5fd943756a8c9b5d91497365 Player Camera Logic 6b3118b5d467f76fc5c175afc9e54eb52efdfb25578380ae0206a19bfaf643fd450f9640f599d36555913701b9e68e63b887df8f2f0ab87264d7a9532ef4e627 e9f5d3d158d2fe3cd0f575711972fcf44a6098ed0bc5b56815474dac8b874aa959c930f36038d606437852da5c4b13ffb0376fd09479e0092c9836f81d4996d6 Player Logic 11eb72973d4e3668ac3b75fa9d6d5d246c5992170d098d10f7026c453bbcf8b79d0ab31701f52b2d5c8849212149009e0480f1b0f268660c518546b96c4441a6 798227bf34c697de436f6c7ff7ec8b2ebbaf7a18b671ffec7a1aa4bf27dfa7f2eefee81b998b6fd9cf0eff31a53fd31634ff1eaad5d72cfcef7e057bec02a2e9","title":"State Flow"},{"location":"reference/state-flow/#state-flow","text":"","title":"State Flow"},{"location":"reference/state-flow/#app-logic","text":"a5dc9b1b5d426960c70a734a436dfece90ef21dcaa9849e348c183a3dc7b4f5c1ec05d40601fc3d7e940ec086641632ea7c6dc7dfde2c17a17e27b9f1db6d77b 116d2aa4babe3e25eb2955a4f6c2adc92694e7d5283cf5a2a99fcb7f7a18980c13f430c1dfca5cae17b0b5ed16ba044c25b9033814d29befba9d7cef83caac98","title":"App Logic"},{"location":"reference/state-flow/#coin-logic","text":"e34fa993fc43c357be28e34513cf202e985ed5c95a4908b6c58d7c368bc348d53551dd36f31fca7968bdd5b02ff82a72ff5cfb1b836cce4f4df6725328184e7b 1169083d9530223d3dae954e555671be78cc739521cc8892ac149b53dba22b0a5b78afd8c725a3d4bd4bd28c9954aa71aa500d1543e7fa357f65c6a9b11c9c77","title":"Coin Logic"},{"location":"reference/state-flow/#game-logic","text":"941fe50d45c82a09d30629f93ce99318d102312ab5a295fea00b1ca73c6e7a27a1925ab6cd3017106b2f3884583bea58db39bfab37edca0fd378f3b0798372d3 b32bc886281c68ed96d6f9fe184ad7b6221f80975e559bae981c6e7bc832def85c3cfb14644287a505eedfdbf3096109d3a4b131f3dc921066e0ec7fa8926eb9","title":"Game Logic"},{"location":"reference/state-flow/#game-typing-logic","text":"ed48db3fa3da6bc16498600ba483b6d46edb886f283599fcaee2a4f9fd379e113009e443b7f0c6fd63c9dee1834ff0138f2f8a4d7c4e6317f99497e6847fe3ca 140edc16054050e9232e9cf653f1e5a61d505bcb582297e13fe92e43169dd71f01b6c9d27206a6d390658c0ac3f91a92f167b91e563c7505dbff9241b9547070","title":"Game Typing Logic"},{"location":"reference/state-flow/#in-game-audio-logic","text":"8e06ee689a964ae3d10df7d14bf0c912d77f3c1c931e3c75b9f94348b878bfcbd2e7b324f1e6b669c89f13c2db5e2e502697d338a9ab6ac56bc07977f7a74aa0 d148dd4d1b7bb67b07e8d5e78889604bf6aa9e656062e3262d3bd57648d06ea1b3af207844e0d2763f5c90abbdf3bb9b2c4a9a66761cd41d95698f52b9dfb0c7","title":"In Game Audio Logic"},{"location":"reference/state-flow/#in-game-u-i-logic","text":"1fa36a0f99d147abb1cf60d1eab07fe31356dc124bcbeb53126eda72863ebcd40541b95cba5921b3f301b9e0458db3117beb4bed6a2ab5bc295382ed5d550c39 5f380453eeab45bd081ebdd0ea879ba074199b96b1dee648a69dfa9b33f007bb5e699c7136eab7f6edb1812f81e54e61ee9b66fb5fd943756a8c9b5d91497365","title":"In Game U I Logic"},{"location":"reference/state-flow/#player-camera-logic","text":"6b3118b5d467f76fc5c175afc9e54eb52efdfb25578380ae0206a19bfaf643fd450f9640f599d36555913701b9e68e63b887df8f2f0ab87264d7a9532ef4e627 e9f5d3d158d2fe3cd0f575711972fcf44a6098ed0bc5b56815474dac8b874aa959c930f36038d606437852da5c4b13ffb0376fd09479e0092c9836f81d4996d6","title":"Player Camera Logic"},{"location":"reference/state-flow/#player-logic","text":"11eb72973d4e3668ac3b75fa9d6d5d246c5992170d098d10f7026c453bbcf8b79d0ab31701f52b2d5c8849212149009e0480f1b0f268660c518546b96c4441a6 798227bf34c697de436f6c7ff7ec8b2ebbaf7a18b671ffec7a1aa4bf27dfa7f2eefee81b998b6fd9cf0eff31a53fd31634ff1eaad5d72cfcef7e057bec02a2e9","title":"Player Logic"},{"location":"tutorial/getting-started/","text":"Getting Started \ud83e\udd5a Getting Started First install GodotEnv which manages our addons: dotnet tool install --global Chickensoft.GodotEnv Then we install all addons with this command: godotenv addons install \ud83c\udfdd Environment Setup For the provided debug configurations and test coverage to work correctly, you must setup your development environment correctly. The [Chickensoft Setup Docs][setup-docs] describe how to setup your Godot and C# development environment, using Chickensoft's best practice recommendations. VSCode Settings This template includes some Visual Studio Code settings in .vscode/settings.json . The settings facilitate terminal environments on Windows (Git Bash, PowerShell, Command Prompt) and macOS (zsh), as well as fixing some syntax colorization issues that Omnisharp suffers from. You'll also find settings that enable editor config support in Omnisharp and the .NET Roslyn analyzers for a more enjoyable coding experience. Please double-check that the provided VSCode settings don't conflict with your existing settings. .NET Versioning The included global.json specifies the version of the .NET SDK and Godot.NET.Sdk that the game should use. Using a global.json file allows [Renovatebot] to provide your repository with automatic dependency update pull requests whenever a new version of [GodotSharp] is released. \ud83c\udfc1 Application Entry Point The Main.tscn and Main.cs scene and script file are the entry point of your game. In general, you probably won't need to modify these unless you're doing something highly custom. If the game is running a release build, the Main.cs file will just immediately change the scene to src/Game.tscn . If the game is running in debug mode and GoDotTest has received the correct command line arguments to begin testing, the game will switch to the testing scene and hand off control to GoDotTest to run the game's tests. In general, prefer editing src/Game.tscn over src/Main.tscn . The provided debug configurations in .vscode/launch.json allow you to easily debug tests (or just the currently open test, provided its filename matches its class name). \u23ef Running the Project Several launch profiles are included for Visual Studio Code: \ud83d\udd79 Debug Game Runs the game in debug mode, allowing you to set breakpoints and inspect variables. \ud83c\udfad Debug Current Scene Debugs the game and loads the scene with the same name and in the same path as the C# file that's actively selected in VSCode: e.g., a scene named MyScene.tscn must reside in the same directory as MyScene.cs , and you must have selected MyScene.cs as the active tab in VSCode before running the launch profile. If GoDotTest is able to find a .tscn file with the same name in the same location, it will run the game in debug mode and load the scene. Naturally, Chickensoft recommends naming scenes after the C# script they use and keeping them in the same directory so that you can take advantage of this launch profile. \u26a0\ufe0f It's very easy to rename a script class but forget to rename the scene file, or vice-versa. When that happens, this launch profile will pass in the expected name of the scene file based on the script's name, but Godot will fail to find a scene with that name since the script name and scene name are not the same. \ud83e\uddea Debug Tests Runs the game in debug mode, specifying the command line flags needed by GoDotTest to run the tests. Debugging works the same as usual, allowing you to set breakpoints within the game's C# test files. \ud83d\udd2c Debug Current Test Debugs the game and loads the test class with the same name as the C# file that's actively selected in VSCode: e.g., a test file named MyTest.cs must contain a test class named MyTest , and you must have selected MyTest.cs as the active tab in VSCode before running the launch profile. \u26a0\ufe0f It's very easy to rename a test class but forget to rename the test file, or vice-versa. When that happens, this launch profile will pass in the name of the file but GoDotTest will fail to find a class with that name since the filename and class name are not the same. Note that each launch profile will trigger a build (see ./.vscode/tasks.json ) before debugging the game. \u26a0\ufe0f Important: You must setup a GODOT environment variable for the launch configurations above. If you haven't done so already, please see the [Chickensoft Setup Docs][setup-docs].","title":"Getting Started"},{"location":"tutorial/getting-started/#getting-started","text":"","title":"Getting Started"},{"location":"tutorial/getting-started/#getting-started_1","text":"First install GodotEnv which manages our addons: dotnet tool install --global Chickensoft.GodotEnv Then we install all addons with this command: godotenv addons install","title":"\ud83e\udd5a Getting Started"},{"location":"tutorial/getting-started/#environment-setup","text":"For the provided debug configurations and test coverage to work correctly, you must setup your development environment correctly. The [Chickensoft Setup Docs][setup-docs] describe how to setup your Godot and C# development environment, using Chickensoft's best practice recommendations.","title":"\ud83c\udfdd Environment Setup"},{"location":"tutorial/getting-started/#vscode-settings","text":"This template includes some Visual Studio Code settings in .vscode/settings.json . The settings facilitate terminal environments on Windows (Git Bash, PowerShell, Command Prompt) and macOS (zsh), as well as fixing some syntax colorization issues that Omnisharp suffers from. You'll also find settings that enable editor config support in Omnisharp and the .NET Roslyn analyzers for a more enjoyable coding experience. Please double-check that the provided VSCode settings don't conflict with your existing settings.","title":"VSCode Settings"},{"location":"tutorial/getting-started/#net-versioning","text":"The included global.json specifies the version of the .NET SDK and Godot.NET.Sdk that the game should use. Using a global.json file allows [Renovatebot] to provide your repository with automatic dependency update pull requests whenever a new version of [GodotSharp] is released.","title":".NET Versioning"},{"location":"tutorial/getting-started/#application-entry-point","text":"The Main.tscn and Main.cs scene and script file are the entry point of your game. In general, you probably won't need to modify these unless you're doing something highly custom. If the game is running a release build, the Main.cs file will just immediately change the scene to src/Game.tscn . If the game is running in debug mode and GoDotTest has received the correct command line arguments to begin testing, the game will switch to the testing scene and hand off control to GoDotTest to run the game's tests. In general, prefer editing src/Game.tscn over src/Main.tscn . The provided debug configurations in .vscode/launch.json allow you to easily debug tests (or just the currently open test, provided its filename matches its class name).","title":"\ud83c\udfc1 Application Entry Point"},{"location":"tutorial/getting-started/#running-the-project","text":"Several launch profiles are included for Visual Studio Code: \ud83d\udd79 Debug Game Runs the game in debug mode, allowing you to set breakpoints and inspect variables. \ud83c\udfad Debug Current Scene Debugs the game and loads the scene with the same name and in the same path as the C# file that's actively selected in VSCode: e.g., a scene named MyScene.tscn must reside in the same directory as MyScene.cs , and you must have selected MyScene.cs as the active tab in VSCode before running the launch profile. If GoDotTest is able to find a .tscn file with the same name in the same location, it will run the game in debug mode and load the scene. Naturally, Chickensoft recommends naming scenes after the C# script they use and keeping them in the same directory so that you can take advantage of this launch profile. \u26a0\ufe0f It's very easy to rename a script class but forget to rename the scene file, or vice-versa. When that happens, this launch profile will pass in the expected name of the scene file based on the script's name, but Godot will fail to find a scene with that name since the script name and scene name are not the same. \ud83e\uddea Debug Tests Runs the game in debug mode, specifying the command line flags needed by GoDotTest to run the tests. Debugging works the same as usual, allowing you to set breakpoints within the game's C# test files. \ud83d\udd2c Debug Current Test Debugs the game and loads the test class with the same name as the C# file that's actively selected in VSCode: e.g., a test file named MyTest.cs must contain a test class named MyTest , and you must have selected MyTest.cs as the active tab in VSCode before running the launch profile. \u26a0\ufe0f It's very easy to rename a test class but forget to rename the test file, or vice-versa. When that happens, this launch profile will pass in the name of the file but GoDotTest will fail to find a class with that name since the filename and class name are not the same. Note that each launch profile will trigger a build (see ./.vscode/tasks.json ) before debugging the game. \u26a0\ufe0f Important: You must setup a GODOT environment variable for the launch configurations above. If you haven't done so already, please see the [Chickensoft Setup Docs][setup-docs].","title":"\u23ef Running the Project"}]}