{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"AnkiTaiso Docs Typing of the Dead inspired Typing Game with support for different alphabets. Optional integration with Anki to practise the vocabulary you are learning.","title":"Home"},{"location":"#ankitaiso-docs","text":"Typing of the Dead inspired Typing Game with support for different alphabets. Optional integration with Anki to practise the vocabulary you are learning.","title":"AnkiTaiso Docs"},{"location":"explanation/documentation-system/","text":"Documentation System Project Documentation organised by The Documentation System . There is a secret that needs to be understood in order to write good software documentation: there isn\u2019t one thing called documentation, there are four. They are: tutorials , how-to guides , technical reference and explanation . They represent four different purposes or functions, and require four different approaches to their creation. Understanding the implications of this will help improve most documentation - often immensely. Tutorials How-to guides Reference Explanation oriented to learning a goal information understanding must allow the newcomer to get started show how to solve a specific problem describe the machinery explain its form a lesson a series of steps dry description discursive explanation analogy teaching a small child how to cook a recipe in a cookery book a reference encyclopedia article an article on culinary social history","title":"Documentation System"},{"location":"explanation/documentation-system/#documentation-system","text":"Project Documentation organised by The Documentation System . There is a secret that needs to be understood in order to write good software documentation: there isn\u2019t one thing called documentation, there are four. They are: tutorials , how-to guides , technical reference and explanation . They represent four different purposes or functions, and require four different approaches to their creation. Understanding the implications of this will help improve most documentation - often immensely. Tutorials How-to guides Reference Explanation oriented to learning a goal information understanding must allow the newcomer to get started show how to solve a specific problem describe the machinery explain its form a lesson a series of steps dry description discursive explanation analogy teaching a small child how to cook a recipe in a cookery book a reference encyclopedia article an article on culinary social history","title":"Documentation System"},{"location":"explanation/how-godot-works/","text":"How Godot works Learning Resources about Godot itself: Introduction to Godot (Official) Key Concepts (Official) Kids Can Code Tutorials In this project we are using ChickenSoft libraries for C#: AutoInject for dependency injection LogicBlocks for state machines Collections for advances collection types Log.Godot for logging If you want to know more about Testing: XUnit for unit tests GoDotTest for integration Tests GodotNodeInterfaces adapters and interfaces to make Godot testable","title":"How Godot works"},{"location":"explanation/how-godot-works/#how-godot-works","text":"Learning Resources about Godot itself: Introduction to Godot (Official) Key Concepts (Official) Kids Can Code Tutorials In this project we are using ChickenSoft libraries for C#: AutoInject for dependency injection LogicBlocks for state machines Collections for advances collection types Log.Godot for logging If you want to know more about Testing: XUnit for unit tests GoDotTest for integration Tests GodotNodeInterfaces adapters and interfaces to make Godot testable","title":"How Godot works"},{"location":"howto/release-version/","text":"How to release The included workflow in .github/workflows/release.yaml can be manually dispatched to - replace the version number in anki-taiso.csproj with the version you specify in the workflow's inputs - create a new commit tagged with the specified version prefixed by v, e.g. v1.2.3 - build a release version for all supported export targets - upload the builds to a new release with an auto generated changelog","title":"Release version"},{"location":"howto/release-version/#how-to-release","text":"The included workflow in .github/workflows/release.yaml can be manually dispatched to - replace the version number in anki-taiso.csproj with the version you specify in the workflow's inputs - create a new commit tagged with the specified version prefixed by v, e.g. v1.2.3 - build a release version for all supported export targets - upload the builds to a new release with an auto generated changelog","title":"How to release"},{"location":"howto/run-tests/","text":"\ud83d\udea5 Run Tests Tests run directly inside the GitHub runner machine (using [chickensoft-games/setup-godot]) on every push to the repository. If the tests fail to pass, the workflow will also fail to pass. You can configure which simulated graphics environments ( vulkan and/or opengl3 ) you want to run tests on in .github/workflows/visual_tests.yaml . Currently, tests can only be run from the ubuntu runners. If you know how to make the workflow install mesa and a virtual window manager on macOS and Windows, we'd love to hear from you! Tests are executed by running the Godot test project in anki-taiso from the command line and passing in the relevant arguments to Godot so that [GoDotTest] can discover and run tests. \ud83d\udc77 Testing [GoDotTest] is an easy-to-use testing framework for Godot and C# that allows you to run tests from the command line, collect code coverage, and debug tests in VSCode. Tests run directly inside the game. The .csproj file is already pre-configured to prevent test scripts and test-only package dependencies from being included in release builds of your game! On CI/CD, software graphics drivers from [mesa] emulate a virtual graphics device for Godot to render to, allowing you to run visual tests in a headless environment. \ud83d\udea6 Test Coverage Code coverage requires a few dotnet global tools to be installed first. You should install these tools from the root of the project directory. The nuget.config file in the root of the project allows the correct version of coverlet to be installed from the coverlet nightly distributions. Overriding the coverlet version will be required [until coverlet releases a stable version with the fixes that allow it to work with Godot 4][coverlet-issues]. dotnet tool install --global coverlet.console dotnet tool update --global coverlet.console dotnet tool install --global dotnet-reportgenerator-globaltool dotnet tool update --global dotnet-reportgenerator-globaltool Running dotnet tool update for the global tool is often necessary on Apple Silicon computers to ensure the tools are installed correctly. You can collect code coverage and generate coverage badges by running the bash script coverage.sh (on Windows, you can use the Git Bash shell that comes with git). # Must give coverage script permission to run the first time it is used. chmod +x ./coverage.sh # Run code coverage: ./coverage.sh You can also run test coverage through VSCode by opening the command palette and selecting Tasks: Run Task and then choosing coverage . If you are having trouble with coverlet finding your .NET runtime on Windows, you can use the PowerShell Script coverage.ps1 instead. .\\coverage.ps1","title":"Run tests"},{"location":"howto/run-tests/#run-tests","text":"Tests run directly inside the GitHub runner machine (using [chickensoft-games/setup-godot]) on every push to the repository. If the tests fail to pass, the workflow will also fail to pass. You can configure which simulated graphics environments ( vulkan and/or opengl3 ) you want to run tests on in .github/workflows/visual_tests.yaml . Currently, tests can only be run from the ubuntu runners. If you know how to make the workflow install mesa and a virtual window manager on macOS and Windows, we'd love to hear from you! Tests are executed by running the Godot test project in anki-taiso from the command line and passing in the relevant arguments to Godot so that [GoDotTest] can discover and run tests.","title":"\ud83d\udea5 Run Tests"},{"location":"howto/run-tests/#testing","text":"[GoDotTest] is an easy-to-use testing framework for Godot and C# that allows you to run tests from the command line, collect code coverage, and debug tests in VSCode. Tests run directly inside the game. The .csproj file is already pre-configured to prevent test scripts and test-only package dependencies from being included in release builds of your game! On CI/CD, software graphics drivers from [mesa] emulate a virtual graphics device for Godot to render to, allowing you to run visual tests in a headless environment.","title":"\ud83d\udc77 Testing"},{"location":"howto/run-tests/#test-coverage","text":"Code coverage requires a few dotnet global tools to be installed first. You should install these tools from the root of the project directory. The nuget.config file in the root of the project allows the correct version of coverlet to be installed from the coverlet nightly distributions. Overriding the coverlet version will be required [until coverlet releases a stable version with the fixes that allow it to work with Godot 4][coverlet-issues]. dotnet tool install --global coverlet.console dotnet tool update --global coverlet.console dotnet tool install --global dotnet-reportgenerator-globaltool dotnet tool update --global dotnet-reportgenerator-globaltool Running dotnet tool update for the global tool is often necessary on Apple Silicon computers to ensure the tools are installed correctly. You can collect code coverage and generate coverage badges by running the bash script coverage.sh (on Windows, you can use the Git Bash shell that comes with git). # Must give coverage script permission to run the first time it is used. chmod +x ./coverage.sh # Run code coverage: ./coverage.sh You can also run test coverage through VSCode by opening the command palette and selecting Tasks: Run Task and then choosing coverage . If you are having trouble with coverlet finding your .NET runtime on Windows, you can use the PowerShell Script coverage.ps1 instead. .\\coverage.ps1","title":"\ud83d\udea6 Test Coverage"},{"location":"reference/godot-editor-shortcuts/","text":"Godot Editor Shortcuts The following are additional Godot Editor Shortcuts via addons: Expand Region ALT+W : expand region (macos CONTROL+W ) ALT+SHIFT+W : shrink region (macos CONTROL+SHIFT+W ) Find Everywhere SHIFT-SHIFT : Quick Open ALT+SHIFT+F : Find in Files (macos CONTROL+SHIFT+F ) Previous Tab Ctrl+Tab : Switch to the previously active tab (last tab) by pressing (macos Option+Tab )","title":"Godot Editor Shortcuts"},{"location":"reference/godot-editor-shortcuts/#godot-editor-shortcuts","text":"The following are additional Godot Editor Shortcuts via addons:","title":"Godot Editor Shortcuts"},{"location":"reference/godot-editor-shortcuts/#expand-region","text":"ALT+W : expand region (macos CONTROL+W ) ALT+SHIFT+W : shrink region (macos CONTROL+SHIFT+W )","title":"Expand Region"},{"location":"reference/godot-editor-shortcuts/#find-everywhere","text":"SHIFT-SHIFT : Quick Open ALT+SHIFT+F : Find in Files (macos CONTROL+SHIFT+F )","title":"Find Everywhere"},{"location":"reference/godot-editor-shortcuts/#previous-tab","text":"Ctrl+Tab : Switch to the previously active tab (last tab) by pressing (macos Option+Tab )","title":"Previous Tab"},{"location":"reference/method-call-order/","text":"Method Call Order Here is the order in which the various methods you can override are called: On Create Order Constructor OnSceneInstantiated Initialise (private) OnParented OnEnterTree _EnterTree _Ready Initialize (public) Setup OnResolved OnBeforeReady OnReady OnAfterReady Please notice that _Ready is called before the dependencies are resolved. That happens in OnResolved or later OnReady . On Free Order OnPredelete _ExitTree OnExitTree OnUnparented Dispose","title":"Method Call Order"},{"location":"reference/method-call-order/#method-call-order","text":"Here is the order in which the various methods you can override are called:","title":"Method Call Order"},{"location":"reference/method-call-order/#on-create-order","text":"Constructor OnSceneInstantiated Initialise (private) OnParented OnEnterTree _EnterTree _Ready Initialize (public) Setup OnResolved OnBeforeReady OnReady OnAfterReady Please notice that _Ready is called before the dependencies are resolved. That happens in OnResolved or later OnReady .","title":"On Create Order"},{"location":"reference/method-call-order/#on-free-order","text":"OnPredelete _ExitTree OnExitTree OnUnparented Dispose","title":"On Free Order"},{"location":"reference/state-flow/","text":"State Flow App Logic a5dc9b1b5d426960c70a734a436dfece90ef21dcaa9849e348c183a3dc7b4f5c1ec05d40601fc3d7e940ec086641632ea7c6dc7dfde2c17a17e27b9f1db6d77b 116d2aa4babe3e25eb2955a4f6c2adc92694e7d5283cf5a2a99fcb7f7a18980c13f430c1dfca5cae17b0b5ed16ba044c25b9033814d29befba9d7cef83caac98 Game Logic 941fe50d45c82a09d30629f93ce99318d102312ab5a295fea00b1ca73c6e7a27a1925ab6cd3017106b2f3884583bea58db39bfab37edca0fd378f3b0798372d3 b32bc886281c68ed96d6f9fe184ad7b6221f80975e559bae981c6e7bc832def85c3cfb14644287a505eedfdbf3096109d3a4b131f3dc921066e0ec7fa8926eb9 In Game Audio Logic 2453056e04f8f3e53186a849bb348a7d3cee15fa2e0fa22034e9d164449c8fc6dbfccd69871a68e7e106a50db5673f3549b6be9aad74a58da2bd696ad42196bf f1fe44882a655e3e10f9015bc7937ebd258069428325e6920739225c37798d7592a6fbc49a738cec1f52fd757f0f509609a30c926fb20739fd6d2cd442ae6971 Player Camera Logic 6b3118b5d467f76fc5c175afc9e54eb52efdfb25578380ae0206a19bfaf643fd450f9640f599d36555913701b9e68e63b887df8f2f0ab87264d7a9532ef4e627 e9f5d3d158d2fe3cd0f575711972fcf44a6098ed0bc5b56815474dac8b874aa959c930f36038d606437852da5c4b13ffb0376fd09479e0092c9836f81d4996d6 Player Logic 11eb72973d4e3668ac3b75fa9d6d5d246c5992170d098d10f7026c453bbcf8b79d0ab31701f52b2d5c8849212149009e0480f1b0f268660c518546b96c4441a6 798227bf34c697de436f6c7ff7ec8b2ebbaf7a18b671ffec7a1aa4bf27dfa7f2eefee81b998b6fd9cf0eff31a53fd31634ff1eaad5d72cfcef7e057bec02a2e9","title":"State Flow"},{"location":"reference/state-flow/#state-flow","text":"","title":"State Flow"},{"location":"reference/state-flow/#app-logic","text":"a5dc9b1b5d426960c70a734a436dfece90ef21dcaa9849e348c183a3dc7b4f5c1ec05d40601fc3d7e940ec086641632ea7c6dc7dfde2c17a17e27b9f1db6d77b 116d2aa4babe3e25eb2955a4f6c2adc92694e7d5283cf5a2a99fcb7f7a18980c13f430c1dfca5cae17b0b5ed16ba044c25b9033814d29befba9d7cef83caac98","title":"App Logic"},{"location":"reference/state-flow/#game-logic","text":"941fe50d45c82a09d30629f93ce99318d102312ab5a295fea00b1ca73c6e7a27a1925ab6cd3017106b2f3884583bea58db39bfab37edca0fd378f3b0798372d3 b32bc886281c68ed96d6f9fe184ad7b6221f80975e559bae981c6e7bc832def85c3cfb14644287a505eedfdbf3096109d3a4b131f3dc921066e0ec7fa8926eb9","title":"Game Logic"},{"location":"reference/state-flow/#in-game-audio-logic","text":"2453056e04f8f3e53186a849bb348a7d3cee15fa2e0fa22034e9d164449c8fc6dbfccd69871a68e7e106a50db5673f3549b6be9aad74a58da2bd696ad42196bf f1fe44882a655e3e10f9015bc7937ebd258069428325e6920739225c37798d7592a6fbc49a738cec1f52fd757f0f509609a30c926fb20739fd6d2cd442ae6971","title":"In Game Audio Logic"},{"location":"reference/state-flow/#player-camera-logic","text":"6b3118b5d467f76fc5c175afc9e54eb52efdfb25578380ae0206a19bfaf643fd450f9640f599d36555913701b9e68e63b887df8f2f0ab87264d7a9532ef4e627 e9f5d3d158d2fe3cd0f575711972fcf44a6098ed0bc5b56815474dac8b874aa959c930f36038d606437852da5c4b13ffb0376fd09479e0092c9836f81d4996d6","title":"Player Camera Logic"},{"location":"reference/state-flow/#player-logic","text":"11eb72973d4e3668ac3b75fa9d6d5d246c5992170d098d10f7026c453bbcf8b79d0ab31701f52b2d5c8849212149009e0480f1b0f268660c518546b96c4441a6 798227bf34c697de436f6c7ff7ec8b2ebbaf7a18b671ffec7a1aa4bf27dfa7f2eefee81b998b6fd9cf0eff31a53fd31634ff1eaad5d72cfcef7e057bec02a2e9","title":"Player Logic"},{"location":"tutorial/getting-started/","text":"Getting Started \ud83e\udd5a Getting Started Requirements: Dotnet 9 Godot 4.4 Mono Then install GodotEnv which manages our addons: dotnet tool install --global Chickensoft.GodotEnv And install all addons with this command: godotenv addons install Optional Tools: For code coverage reports you may also install those tools: dotnet tool install --global coverlet.console dotnet tool update --global coverlet.console dotnet tool install --global dotnet-reportgenerator-globaltool dotnet tool update --global dotnet-reportgenerator-globaltool \ud83c\udfdd Environment Setup For the provided debug configurations and test coverage to work correctly, you must setup your development environment correctly. The [Chickensoft Setup Docs][setup-docs] describe how to setup your Godot and C# development environment, using Chickensoft's best practice recommendations. VSCode Settings This template includes some Visual Studio Code settings in .vscode/settings.json . The settings facilitate terminal environments on Windows (Git Bash, PowerShell, Command Prompt) and macOS (zsh), as well as fixing some syntax colorization issues that Omnisharp suffers from. You'll also find settings that enable editor config support in Omnisharp and the .NET Roslyn analyzers for a more enjoyable coding experience. Please double-check that the provided VSCode settings don't conflict with your existing settings. \ud83c\udfc1 Application Entry Point The Main.tscn and Main.cs scene and script file are the entry point of the game. In general, you probably won't need to modify these unless you're doing something highly custom. If the game is running a release build, the Main.cs file will just immediately change the scene to src/Game.tscn . If the game is running in debug mode and GoDotTest has received the correct command line arguments to begin testing, the game will switch to the testing scene and hand off control to GoDotTest to run the game's tests. In general, prefer editing src/Game.tscn over src/Main.tscn . The provided debug configurations in .vscode/launch.json allow you to easily debug tests (or just the currently open test, provided its filename matches its class name). \u23ef Running the Project Several launch profiles are included for Visual Studio Code: \ud83d\udd79 Debug Game Runs the game in debug mode, allowing you to set breakpoints and inspect variables. \ud83c\udfad Debug Current Scene Debugs the game and loads the scene with the same name and in the same path as the C# file that's actively selected in VSCode: e.g., a scene named MyScene.tscn must reside in the same directory as MyScene.cs , and you must have selected MyScene.cs as the active tab in VSCode before running the launch profile. If GoDotTest is able to find a .tscn file with the same name in the same location, it will run the game in debug mode and load the scene. Naturally, Chickensoft recommends naming scenes after the C# script they use and keeping them in the same directory so that you can take advantage of this launch profile. \u26a0\ufe0f It's very easy to rename a script class but forget to rename the scene file, or vice-versa. When that happens, this launch profile will pass in the expected name of the scene file based on the script's name, but Godot will fail to find a scene with that name since the script name and scene name are not the same. \ud83e\uddea Debug Tests Runs the game in debug mode, specifying the command line flags needed by GoDotTest to run the tests. Debugging works the same as usual, allowing you to set breakpoints within the game's C# test files. \ud83d\udd2c Debug Current Test Debugs the game and loads the test class with the same name as the C# file that's actively selected in VSCode: e.g., a test file named MyTest.cs must contain a test class named MyTest , and you must have selected MyTest.cs as the active tab in VSCode before running the launch profile. \u26a0\ufe0f It's very easy to rename a test class but forget to rename the test file, or vice-versa. When that happens, this launch profile will pass in the name of the file but GoDotTest will fail to find a class with that name since the filename and class name are not the same. Note that each launch profile will trigger a build (see ./.vscode/tasks.json ) before debugging the game. \u26a0\ufe0f Important: You must setup a GODOT environment variable for the launch configurations above. If you haven't done so already, please see the [Chickensoft Setup Docs][setup-docs].","title":"Getting Started"},{"location":"tutorial/getting-started/#getting-started","text":"","title":"Getting Started"},{"location":"tutorial/getting-started/#getting-started_1","text":"Requirements: Dotnet 9 Godot 4.4 Mono Then install GodotEnv which manages our addons: dotnet tool install --global Chickensoft.GodotEnv And install all addons with this command: godotenv addons install","title":"\ud83e\udd5a Getting Started"},{"location":"tutorial/getting-started/#optional-tools","text":"For code coverage reports you may also install those tools: dotnet tool install --global coverlet.console dotnet tool update --global coverlet.console dotnet tool install --global dotnet-reportgenerator-globaltool dotnet tool update --global dotnet-reportgenerator-globaltool","title":"Optional Tools:"},{"location":"tutorial/getting-started/#environment-setup","text":"For the provided debug configurations and test coverage to work correctly, you must setup your development environment correctly. The [Chickensoft Setup Docs][setup-docs] describe how to setup your Godot and C# development environment, using Chickensoft's best practice recommendations.","title":"\ud83c\udfdd Environment Setup"},{"location":"tutorial/getting-started/#vscode-settings","text":"This template includes some Visual Studio Code settings in .vscode/settings.json . The settings facilitate terminal environments on Windows (Git Bash, PowerShell, Command Prompt) and macOS (zsh), as well as fixing some syntax colorization issues that Omnisharp suffers from. You'll also find settings that enable editor config support in Omnisharp and the .NET Roslyn analyzers for a more enjoyable coding experience. Please double-check that the provided VSCode settings don't conflict with your existing settings.","title":"VSCode Settings"},{"location":"tutorial/getting-started/#application-entry-point","text":"The Main.tscn and Main.cs scene and script file are the entry point of the game. In general, you probably won't need to modify these unless you're doing something highly custom. If the game is running a release build, the Main.cs file will just immediately change the scene to src/Game.tscn . If the game is running in debug mode and GoDotTest has received the correct command line arguments to begin testing, the game will switch to the testing scene and hand off control to GoDotTest to run the game's tests. In general, prefer editing src/Game.tscn over src/Main.tscn . The provided debug configurations in .vscode/launch.json allow you to easily debug tests (or just the currently open test, provided its filename matches its class name).","title":"\ud83c\udfc1 Application Entry Point"},{"location":"tutorial/getting-started/#running-the-project","text":"Several launch profiles are included for Visual Studio Code: \ud83d\udd79 Debug Game Runs the game in debug mode, allowing you to set breakpoints and inspect variables. \ud83c\udfad Debug Current Scene Debugs the game and loads the scene with the same name and in the same path as the C# file that's actively selected in VSCode: e.g., a scene named MyScene.tscn must reside in the same directory as MyScene.cs , and you must have selected MyScene.cs as the active tab in VSCode before running the launch profile. If GoDotTest is able to find a .tscn file with the same name in the same location, it will run the game in debug mode and load the scene. Naturally, Chickensoft recommends naming scenes after the C# script they use and keeping them in the same directory so that you can take advantage of this launch profile. \u26a0\ufe0f It's very easy to rename a script class but forget to rename the scene file, or vice-versa. When that happens, this launch profile will pass in the expected name of the scene file based on the script's name, but Godot will fail to find a scene with that name since the script name and scene name are not the same. \ud83e\uddea Debug Tests Runs the game in debug mode, specifying the command line flags needed by GoDotTest to run the tests. Debugging works the same as usual, allowing you to set breakpoints within the game's C# test files. \ud83d\udd2c Debug Current Test Debugs the game and loads the test class with the same name as the C# file that's actively selected in VSCode: e.g., a test file named MyTest.cs must contain a test class named MyTest , and you must have selected MyTest.cs as the active tab in VSCode before running the launch profile. \u26a0\ufe0f It's very easy to rename a test class but forget to rename the test file, or vice-versa. When that happens, this launch profile will pass in the name of the file but GoDotTest will fail to find a class with that name since the filename and class name are not the same. Note that each launch profile will trigger a build (see ./.vscode/tasks.json ) before debugging the game. \u26a0\ufe0f Important: You must setup a GODOT environment variable for the launch configurations above. If you haven't done so already, please see the [Chickensoft Setup Docs][setup-docs].","title":"\u23ef Running the Project"}]}